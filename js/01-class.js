/**
 * Класи
 *  - Оголошення класу
 *  - Конструктор класу
 *  - Методи класу
 *  - Прототип екземпляру
 *  - Приватні властивості
 *  - Геттери і сеттери
 *  - Статичні властивості
 */

//* клас - це такий собі завод який описує поля та методи для одного обʼєкту і використовується для створення нових обʼєктів. Шаблон на основі якого створюються нові обʼєкти. Якщо заглянути під капот, то клас - це звичайний синтаксичний цукор старої фукнції конструктора якою раніше користувались в джс.
class Car {
  // оголошення статичної властивості - це звичайна властивість до якої можна звернутись тільки через сам клас. Оскільки клас - це фукція, а фукнція - це обʼєкт, то ми можемо створювати власні властивості і зберігати їх там. Статичні властивості не наслідуються і не додаються у екземпляри
  static description = "Клас для реалізації автомобіля!";
  static carsAmount = 0;

  static addOneCar() {
    this.carsAmount += 1;
  }

  static getCarsAmount() {
    console.log(`Кількість створених екземплярів: ${this.carsAmount}`);
  }

  // оголошення приватної властивості
  #owner;

  // constructor - метод, який викликається під час створення екземпляру класу (зазвичай тут описують майбутні поля які будуть у обʼєкта (екземпляра) та якусь ініціалізацію за необхідності)
  constructor(brand, model, price, owner) {
    Car.addOneCar(); // збільшуємо лічільник автомобілів
    // публічні властивості - додаються у екземпляр та наслідуються
    this.brand = brand;
    this.model = model;
    this.price = price;
    // приватна властивість - не додається у екземпляр та не наслідується (вона доступна тільки всередині класу і все). Приватні властивості потрібно оголошувати у самому класу (за межами конструктору)
    this.#owner = owner;
  }

  // публічний метод - його можна викликати з будь-якого екземпляру (він наслідується та додається у екземпляри)
  displayCarInfo() {
    console.log(
      `Марка: ${this.brand}\nМодель: ${this.model}\nЦіна: ${this.price}$`
    );
  }

  // приватний метод - його можна викликати тільки в самому класі, він не наслідується і не додається у екземпляри
  #checkOwner() {
    const userAnswer = prompt(
      "Введіть поточного власника для підтвердження операції:"
    );
    return userAnswer === this.#owner;
  }

  // методи аксесори - це спеціальні синтакстичні конструкції за допомогою яких ми можемо прочитати або перезаписати приватні властивості (накливши деякі обмеження чи перевірки). Згадуйте про викрутку для чайнику

  // get (читання) set (перезапис)
  // насправді під капотом цей аксесор просто створить вам нову публічну властивість owner
  get owner() {
    if (this.#checkOwner()) {
      return this.#owner;
    } else {
      console.log("Операція неможлива!");
    }
  }

  set owner(newOwner) {
    if (this.#checkOwner()) {
      this.#owner = newOwner;
      console.log(`Власник успішно змінений! Новий власник: ${newOwner}`);
    } else {
      console.log("Поточний власник не є коректним! Спробуйте ще раз!");
    }
  }
}

console.dir(Car);
console.log(Car.description);

// створення екземпляру класу (це конкретний предствник класу, тобто, обʼєкт, який був створений на основі цього класу)

/*
що робить оператор new
- створює пустий обʼєкт - const car = {}
- викликає конструктор класу в контексті новоствореного обʼєкту (всередині конструктора this буде посилатись на ваш пустий обʼєкт {})
*/

const infinity = new Car("Infinity", "Q60s", 35000, "Jack");
infinity.displayCarInfo();

console.log(infinity);
console.log(infinity.brand);
//! console.log(infinity.#owner); // звертатись до приватних властивостей неможливо - вони доступні тільки в самому класі
// infinity.owner = "Nick";
// console.log(infinity.owner);

const bmw = new Car("BMW", "M5", 100000, "Lina");
// bmw.displayCarInfo();

Car.getCarsAmount();
